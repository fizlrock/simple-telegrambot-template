/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.telegram.telegrambots.client.okhttp.OkHttpTelegramClient;
import org.telegram.telegrambots.longpolling.TelegramBotsLongPollingApplication;
import org.telegram.telegrambots.longpolling.util.LongPollingSingleThreadUpdateConsumer;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.message.Message;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
import org.telegram.telegrambots.meta.generics.TelegramClient;

public abstract class TGBot {

  private static TelegramBotsLongPollingApplication botsApplication =
      new TelegramBotsLongPollingApplication();

  private static TelegramClient telegramClient;

  private static String token;

  private static Object logicObject;

  private static HashMap<String, Method> handlers = new HashMap<>();

  private static void consume(Msg msg) {

    try {

      String ans;
      if (msg.text.equals("/help")) ans = getHelpMessage();
      else ans = toAnswer(msg);
      SendMessage smsg = SendMessage.builder().chatId(msg.chat_id).text(ans).build();
      telegramClient.execute(smsg);

    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  private static String toAnswer(Msg msg) {

    if (!msg.text.startsWith("/")) return "Разрешено писать только команды";

    var parts =
        Stream.of(msg.text.split(" ")).filter(t -> !t.isBlank()).map(String::strip).toList();

    System.out.println(parts);

    var command_name = parts.get(0).substring(1);

    var handler = handlers.get(command_name);
    if (handler == null) return "Нет обработчика для команды: " + command_name;

    var args = handler.getParameters();

    if (args.length != (parts.size() - 1)) return "Число аргументов не совпадает";

    Object[] mappet_args = new Object[args.length];

    Map<Class<?>, Function<String, Object>> mappers =
        Map.of(
            String.class, (x) -> x,
            Integer.class, (x) -> Integer.parseInt(x),
            Long.class, (x) -> Long.parseLong(x),
            Double.class, (x) -> Double.parseDouble(x),
            Float.class, (x) -> Float.parseFloat(x),
            int.class, (x) -> (int) Integer.parseInt(x),
            long.class, (x) -> (long) Long.parseLong(x),
            double.class, (x) -> (double) Double.parseDouble(x),
            float.class, (x) -> (float) Float.parseFloat(x));

    for (int i = 0; i < args.length; i++) {
      var raw_value = parts.get(i + 1);
      var type = args[i].getType();
      mappet_args[i] = mappers.get(type).apply(raw_value);
    }

    String ans;
    try {
      ans = (String) handler.invoke(logicObject, mappet_args);
    } catch (IllegalAccessException | InvocationTargetException e) {
      throw new RuntimeException(e);
    }
    return ans;
  }

  protected static void setToken(String token) {
    TGBot.token = token;
  }

  protected static void start() {

    StackWalker.StackFrame caller =
        StackWalker.getInstance().walk(frames -> frames.skip(1).findFirst()).get();

    telegramClient = new OkHttpTelegramClient(token);

    try {
      var classname = caller.getClassName();
      var clazz = Class.forName(classname);
      logicObject = clazz.getDeclaredConstructor().newInstance();

      var need_methods =
          Stream.of(clazz.getDeclaredMethods()).filter(m -> m.isAnnotationPresent(Command.class));

      need_methods.forEach(
          m -> {
            String value = m.getAnnotation(Command.class).value();
            handlers.put(value, m);
          });

    } catch (Exception e) {
      e.printStackTrace();
    }

    System.out.println(handlers);

    try {
      botsApplication.registerBot(token, new Bot(TGBot::consume));
    } catch (TelegramApiException e) {
      e.printStackTrace();
    }
  }

  static String getHelpMessage() {
    var body =
        handlers.entrySet().stream()
            .map(TGBot::commandMethodFormatter)
            .collect(Collectors.joining("\n"));
    var header = "Доступные методы: \n";

    return header + body;
  }

  static String commandMethodFormatter(Entry<String, Method> entry) {

    var commandName = entry.getKey();
    var args = entry.getValue().getParameterTypes();

    Map<Class<?>, String> mappers =
        Map.of(
            String.class, "строка",
            Long.class, "число",
            Integer.class, "число",
            long.class, "число",
            int.class, "число",
            Float.class, "дробное число",
            Double.class, "дробное число",
            float.class, "дробное число",
            double.class, "дробное число");

    var argsDescription =
        Stream.of(args).map(mappers::get).map(n -> "<" + n + ">").collect(Collectors.joining(" "));

    return "/" + commandName + " " + argsDescription;
  }

  static class Bot implements LongPollingSingleThreadUpdateConsumer {

    private Consumer<Msg> con;

    public Bot(Consumer<Msg> consumer) {
      con = consumer;
    }

    @Override
    public void consume(Update update) {

      if (update.hasMessage()) {
        Message message = update.getMessage();

        // Проверяем, что сообщение текстовое и отправлено лично боту
        if (message.isUserMessage() && message.hasText()) {
          String text = message.getText();
          String userName = message.getFrom().getUserName();

          // Выводим информацию о сообщении
          System.out.println(userName + " say " + text);
          con.accept(new Msg(userName, message.getChatId(), text));
        }
      }
    }
  }

  record Msg(String username, long chat_id, String text) {}
}
